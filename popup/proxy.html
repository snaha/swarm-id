<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Swarm ID Proxy</title>
    <style>
      body {
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        padding: 0;
        margin: 0;
        background: transparent;
      }

      .proxy-container {
        padding: 12px;
        text-align: center;
      }

      .login-button {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        border: none;
        padding: 10px 24px;
        border-radius: 6px;
        font-size: 14px;
        font-weight: 600;
        cursor: pointer;
        transition: transform 0.2s, box-shadow 0.2s;
        box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
      }

      .login-button:hover {
        transform: translateY(-1px);
        box-shadow: 0 4px 12px rgba(102, 126, 234, 0.5);
      }

      .login-button:active {
        transform: translateY(0);
      }

      .status-text {
        font-size: 13px;
        color: #666;
        margin-top: 8px;
      }

      .status-indicator {
        display: inline-block;
        width: 8px;
        height: 8px;
        border-radius: 50%;
        margin-right: 6px;
        vertical-align: middle;
      }

      .status-indicator.authenticated {
        background: #28a745;
      }

      .status-indicator.unauthenticated {
        background: #dc3545;
      }

      .authenticated-status {
        color: #28a745;
        font-weight: 600;
      }
    </style>
  </head>
  <body>
    <div class="proxy-container">
      <button id="login-button" class="login-button" onclick="openAuthPopup()">
        üîê Login with Swarm ID
      </button>
      <div class="status-text" id="status-text">
        <span class="status-indicator" id="status-indicator"></span>
        <span id="status-message">Not authenticated</span>
      </div>
    </div>

    <script type="module">
      /**
       * Swarm ID Proxy Iframe
       *
       * This iframe acts as a proxy for Bee API calls. It:
       * 1. Receives app-specific secrets from the auth popup
       * 2. Stores secrets in partitioned localStorage (one per app)
       * 3. Proxies Bee API calls from the parent dApp
       * 4. Augments requests with postage stamps and secrets
       * 5. Returns responses to the parent dApp
       */

      // Configuration
      const ALLOWED_PARENT_ORIGINS = [
        'https://swarm-app.local:8080',
        // Add more allowed origins here
      ];

      // State
      let parentOrigin = null;
      let parentIdentified = false;
      let authenticated = false;
      let appSecret = null;

      // Update UI
      function updateStatus(status, text) {
        const indicator = document.getElementById('status-indicator');
        const statusMessage = document.getElementById('status-message');
        const loginButton = document.getElementById('login-button');

        if (status === 'authenticated') {
          indicator.className = 'status-indicator authenticated';
          statusMessage.textContent = 'Authenticated ‚úì';
          statusMessage.className = 'authenticated-status';
          loginButton.style.display = 'none';
        } else {
          indicator.className = 'status-indicator unauthenticated';
          statusMessage.textContent = text || 'Not authenticated';
          statusMessage.className = '';
          loginButton.style.display = 'inline-block';
        }
      }

      // Initialize - Wait for parent to identify itself
      console.log('[Proxy] Waiting for parent to identify...');
      updateStatus('unauthenticated', 'Waiting for parent...');
      document.getElementById('login-button').disabled = true;

      // Validate origin
      function isAllowedOrigin(origin) {
        return ALLOWED_PARENT_ORIGINS.includes(origin);
      }

      // Load app secret from partitioned localStorage
      function loadSecret() {
        if (!parentOrigin) {
          console.log('[Proxy] No parent origin, cannot load secret');
          return null;
        }

        const storageKey = `swarm-secret-${parentOrigin}`;
        const secret = localStorage.getItem(storageKey);

        if (secret) {
          console.log('[Proxy] Secret loaded from localStorage for:', parentOrigin);
          appSecret = secret;
          authenticated = true;
          updateStatus('authenticated');
          return secret;
        } else {
          console.log('[Proxy] No secret found for:', parentOrigin);
          updateStatus('unauthenticated', 'No secret found');
          return null;
        }
      }

      // Save app secret to partitioned localStorage
      function saveSecret(origin, secret) {
        const storageKey = `swarm-secret-${origin}`;
        localStorage.setItem(storageKey, secret);
        console.log('[Proxy] Secret saved to localStorage for:', origin);
      }

      // Check if authenticated
      function checkAuth() {
        loadSecret();
        return authenticated;
      }

      // Open authentication popup (called by button click)
      window.openAuthPopup = function() {
        console.log('[Proxy] Opening authentication popup for parent:', parentOrigin);

        // Pass parent origin as URL parameter
        const authUrl = `${window.location.origin}/connect?origin=${encodeURIComponent(parentOrigin)}`;
        window.open(authUrl);
      };

      // Handle message from parent or popup
      window.addEventListener('message', async (event) => {
        console.log('[Proxy] Message received:', event.data.type, 'from:', event.origin);

        const { type, ...data } = event.data;

        // Handle parent identification (must come first)
        if (type === 'parentIdentify') {
          // Prevent parent from changing after first identification
          if (parentIdentified) {
            console.error('[Proxy] Parent already identified! Ignoring duplicate.');
            return;
          }

          // Trust event.origin - this is browser-enforced and cannot be spoofed
          parentOrigin = event.origin;
          parentIdentified = true;

          console.log('[Proxy] Parent identified via postMessage:', parentOrigin);
          console.log('[Proxy] Parent locked in - cannot be changed');

          // Validate parent is in allowlist
          if (!isAllowedOrigin(parentOrigin)) {
            console.warn('[Proxy] Parent origin not in allowlist:', parentOrigin);
            updateStatus('unauthenticated', 'Parent not in allowlist');
            document.getElementById('login-button').disabled = true;
            return;
          }

          // Enable login button and check for existing auth
          document.getElementById('login-button').disabled = false;
          checkAuth();

          // Acknowledge receipt
          event.source.postMessage(
            { type: 'proxyReady', parentOrigin: parentOrigin },
            event.origin
          );

          return;
        }

        // All other messages require parent to be identified first
        if (!parentIdentified) {
          console.warn('[Proxy] Ignoring message - parent not identified yet');
          return;
        }

        // Validate origin
        const isPopup = event.origin === window.location.origin;
        const isParent = event.origin === parentOrigin;

        if (!isPopup && !isParent) {
          console.warn('[Proxy] Rejected message from unauthorized origin:', event.origin);
          return;
        }

        try {
          switch (type) {
            case 'requestAuth':
              // From parent dApp - open auth popup
              openAuthPopup();
              break;

            case 'setSecret':
              // From auth popup
              await handleSetSecret(data, event);
              break;

            case 'checkAuth':
              // From parent dApp
              await handleCheckAuth(data, event);
              break;

            case 'uploadChunk':
              // From parent dApp
              await handleUploadChunk(data, event);
              break;

            case 'downloadChunk':
              // From parent dApp
              await handleDownloadChunk(data, event);
              break;

            default:
              console.warn('[Proxy] Unknown message type:', type);
              event.source.postMessage({
                type: 'error',
                requestId: data.requestId,
                error: `Unknown message type: ${type}`
              }, event.origin);
          }
        } catch (error) {
          console.error('[Proxy] Error handling message:', error);
          event.source.postMessage({
            type: 'error',
            requestId: data.requestId,
            error: error.message
          }, event.origin);
        }
      });

      // Handle setSecret from auth popup
      async function handleSetSecret(data, event) {
        const { appOrigin, secret } = data;

        console.log('[Proxy] Received secret for app:', appOrigin);

        // Validate that appOrigin matches parent origin
        if (appOrigin !== parentOrigin) {
          console.warn('[Proxy] App origin mismatch:', appOrigin, 'vs', parentOrigin);
          // Still save it, but log warning
        }

        // Save secret to partitioned localStorage
        saveSecret(appOrigin, secret);
        appSecret = secret;
        authenticated = true;
        updateStatus('authenticated');

        // Notify parent dApp
        if (parentOrigin && window.parent !== window.self) {
          window.parent.postMessage({
            type: 'authSuccess',
            origin: appOrigin
          }, parentOrigin);
          console.log('[Proxy] Notified parent of successful authentication');
        }

        // Respond to popup (if still open)
        if (event.source && !event.source.closed) {
          event.source.postMessage({
            type: 'secretReceived',
            success: true
          }, event.origin);
        }
      }

      // Handle checkAuth from parent dApp
      async function handleCheckAuth(data, event) {
        const { requestId } = data;

        console.log('[Proxy] Checking authentication status...');
        const isAuth = checkAuth();

        event.source.postMessage({
          type: 'checkAuthResponse',
          requestId,
          authenticated: isAuth
        }, event.origin);

        console.log('[Proxy] Authentication status:', isAuth);
      }

      // Handle uploadChunk from parent dApp
      async function handleUploadChunk(data, event) {
        const { requestId, data: chunkData } = data;

        console.log('[Proxy] Upload chunk request, size:', chunkData ? chunkData.length : 0);

        if (!authenticated || !appSecret) {
          throw new Error('Not authenticated. Please login first.');
        }

        // TODO: Implement actual Bee API call with bee-js
        // For now, simulate upload with hash
        const hash = await simulateUpload(chunkData);

        event.source.postMessage({
          type: 'uploadChunkResponse',
          requestId,
          reference: hash
        }, event.origin);

        console.log('[Proxy] Chunk uploaded:', hash);
      }

      // Handle downloadChunk from parent dApp
      async function handleDownloadChunk(data, event) {
        const { requestId, reference } = data;

        console.log('[Proxy] Download chunk request, reference:', reference);

        if (!authenticated || !appSecret) {
          throw new Error('Not authenticated. Please login first.');
        }

        // TODO: Implement actual Bee API call with bee-js
        // For now, simulate download
        const chunkData = await simulateDownload(reference);

        event.source.postMessage({
          type: 'downloadChunkResponse',
          requestId,
          data: chunkData
        }, event.origin);

        console.log('[Proxy] Chunk downloaded:', reference);
      }

      // Simulate upload (placeholder for bee-js integration)
      async function simulateUpload(data) {
        // Hash the data using SHA-256
        const uint8Data = new Uint8Array(data);
        const hashBuffer = await crypto.subtle.digest('SHA-256', uint8Data);
        const hashArray = Array.from(new Uint8Array(hashBuffer));
        const hashHex = hashArray.map(b => b.toString(16).padStart(2, '0')).join('');

        // In real implementation, this would:
        // 1. Get postage stamp from storage or API
        // 2. Use bee-js to upload chunk with secret
        // 3. Return actual Swarm reference

        console.log('[Proxy] Simulated upload, hash:', hashHex);
        return hashHex;
      }

      // Simulate download (placeholder for bee-js integration)
      async function simulateDownload(reference) {
        // In real implementation, this would:
        // 1. Use bee-js to download chunk from Swarm
        // 2. Decrypt if necessary using secret
        // 3. Return chunk data

        console.log('[Proxy] Simulated download, reference:', reference);

        // Return dummy data for now
        const dummyData = new Uint8Array([1, 2, 3, 4, 5]);
        return Array.from(dummyData);
      }

      // Initialize
      console.log('[Proxy] Proxy iframe initialized');
      // Note: checkAuth() will be called after parent identifies itself
    </script>
  </body>
</html>
